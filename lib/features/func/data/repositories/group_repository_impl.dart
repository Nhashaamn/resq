import 'package:dartz/dartz.dart';
import 'package:injectable/injectable.dart';
import 'package:resq/core/error/failures.dart';
import 'package:resq/features/func/data/datasources/group_remote_datasource.dart';
import 'package:resq/features/func/data/models/group_message_model.dart';
import 'package:resq/features/func/data/models/group_model.dart';
import 'package:resq/features/func/domain/entities/group.dart';
import 'package:resq/features/func/domain/entities/group_message.dart';
import 'package:resq/features/func/domain/repositories/group_repository.dart';

@LazySingleton(as: GroupRepository)
class GroupRepositoryImpl implements GroupRepository {
  final GroupRemoteDataSource remoteDataSource;

  GroupRepositoryImpl(this.remoteDataSource);

  @override
  Future<Either<Failure, Group>> createGroup({
    required String name,
    required String createdBy,
    required String createdByName,
    String? description,
  }) async {
    try {
      final group = GroupModel(
        id: '',
        name: name,
        createdBy: createdBy,
        createdByName: createdByName,
        createdAt: DateTime.now(),
        memberIds: [createdBy],
        inviteCode: '', // Will be generated by datasource
        description: description,
      );

      final createdGroup = await remoteDataSource.createGroup(group);
      return Right(createdGroup.toDomain());
    } catch (e) {
      return Left(Failure.network(e.toString()));
    }
  }

  @override
  Future<Either<Failure, Group>> joinGroup({
    required String inviteCode,
    required String userId,
    required String userName,
    required String userEmail,
  }) async {
    try {
      final group = await remoteDataSource.joinGroup(inviteCode, userId, userName, userEmail);
      return Right(group.toDomain());
    } catch (e) {
      return Left(Failure.network(e.toString()));
    }
  }

  @override
  Stream<Either<Failure, List<Group>>> getUserGroups(String userId) {
    return remoteDataSource.getUserGroups(userId).map<Either<Failure, List<Group>>>((models) {
      final groups = models.map((model) => model.toDomain()).toList();
      return Right(groups);
    }).handleError((error) {
      return Left(Failure.network(error.toString()));
    });
  }

  @override
  Future<Either<Failure, Group>> getGroup(String groupId) async {
    try {
      final group = await remoteDataSource.getGroup(groupId);
      return Right(group.toDomain());
    } catch (e) {
      return Left(Failure.network(e.toString()));
    }
  }

  @override
  Future<Either<Failure, Unit>> addMemberToGroup({
    required String groupId,
    required String userId,
    required String userName,
    required String userEmail,
  }) async {
    try {
      await remoteDataSource.addMemberToGroup(groupId, userId, userName, userEmail);
      return const Right(unit);
    } catch (e) {
      return Left(Failure.network(e.toString()));
    }
  }

  @override
  Future<Either<Failure, Unit>> removeMemberFromGroup({
    required String groupId,
    required String userId,
  }) async {
    try {
      await remoteDataSource.removeMemberFromGroup(groupId, userId);
      return const Right(unit);
    } catch (e) {
      return Left(Failure.network(e.toString()));
    }
  }

  @override
  Stream<Either<Failure, List<GroupMessage>>> streamGroupMessages(String groupId) {
    return remoteDataSource.streamGroupMessages(groupId).map<Either<Failure, List<GroupMessage>>>((models) {
      final messages = models.map((model) => model.toDomain()).toList();
      // Reverse to show oldest first (newest at bottom)
      return Right(messages.reversed.toList());
    }).handleError((error) {
      return Left(Failure.network(error.toString()));
    });
  }

  @override
  Future<Either<Failure, Unit>> sendGroupMessage({
    required String groupId,
    required String userId,
    required String userName,
    required String text,
    String? replyToMessageId,
    String? replyToUserName,
    String? replyToText,
  }) async {
    try {
      final message = GroupMessageModel(
        id: '',
        groupId: groupId,
        userId: userId,
        userName: userName,
        text: text,
        timestamp: DateTime.now(),
        replyToMessageId: replyToMessageId,
        replyToUserName: replyToUserName,
        replyToText: replyToText,
      );

      await remoteDataSource.sendGroupMessage(message);
      return const Right(unit);
    } catch (e) {
      return Left(Failure.network(e.toString()));
    }
  }

  @override
  Future<Either<Failure, Unit>> deleteGroupMessage({
    required String groupId,
    required String messageId,
    required String userId,
  }) async {
    try {
      await remoteDataSource.deleteGroupMessage(groupId, messageId);
      return const Right(unit);
    } catch (e) {
      return Left(Failure.network(e.toString()));
    }
  }

  @override
  Future<Either<Failure, Unit>> leaveGroup({
    required String groupId,
    required String userId,
  }) async {
    try {
      await remoteDataSource.leaveGroup(groupId, userId);
      return const Right(unit);
    } catch (e) {
      return Left(Failure.network(e.toString()));
    }
  }
}

