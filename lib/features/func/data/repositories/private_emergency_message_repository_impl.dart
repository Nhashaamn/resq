import 'package:dartz/dartz.dart';
import 'package:injectable/injectable.dart';
import 'package:resq/core/error/failures.dart';
import 'package:resq/features/func/data/datasources/private_emergency_message_remote_datasource.dart';
import 'package:resq/features/func/data/models/private_emergency_message_model.dart';
import 'package:resq/features/func/domain/entities/private_emergency_message.dart';
import 'package:resq/features/func/domain/repositories/private_emergency_message_repository.dart';

@LazySingleton(as: PrivateEmergencyMessageRepository)
class PrivateEmergencyMessageRepositoryImpl
    implements PrivateEmergencyMessageRepository {
  final PrivateEmergencyMessageRemoteDataSource remoteDataSource;

  PrivateEmergencyMessageRepositoryImpl(this.remoteDataSource);

  @override
  Future<Either<Failure, Unit>> sendPrivateEmergencyMessage({
    required String fromUserId,
    required String fromUserName,
    required String toEmail,
    required String toPhoneNumber,
    required String message,
  }) async {
    try {
      final model = PrivateEmergencyMessageModel(
        id: '', // Will be generated by Firestore
        fromUserId: fromUserId,
        fromUserName: fromUserName,
        toEmail: toEmail,
        toPhoneNumber: toPhoneNumber,
        message: message,
        timestamp: DateTime.now(),
      );

      await remoteDataSource.sendPrivateEmergencyMessage(model);
      return const Right(unit);
    } catch (e) {
      return Left(Failure.network(e.toString()));
    }
  }

  @override
  Stream<Either<Failure, List<PrivateEmergencyMessage>>> streamPrivateEmergencyMessages(
      String userEmail) async* {
    try {
      yield* remoteDataSource
          .streamPrivateEmergencyMessages(userEmail)
          .map((models) {
            final messages = models.map((model) => model.toDomain()).toList();
            return Right<Failure, List<PrivateEmergencyMessage>>(messages);
          });
    } catch (e) {
      yield Left<Failure, List<PrivateEmergencyMessage>>(
        Failure.network(e.toString()),
      );
    }
  }

  @override
  Future<Either<Failure, Unit>> markAsRead(String messageId) async {
    try {
      await remoteDataSource.markAsRead(messageId);
      return const Right(unit);
    } catch (e) {
      return Left(Failure.network(e.toString()));
    }
  }
}

